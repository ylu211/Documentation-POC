import fs from 'fs';
import path from 'path';
import glob from 'glob';
import { fileURLToPath } from 'url';
import crypto from 'crypto';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

const ROUTES_DIR = path.join(__dirname, '../routes');
const CONTROLLERS_DIR = path.join(__dirname, '../controllers');
const SERVICES_DIR = path.join(__dirname, '../services');
const MIDDLEWARES_DIR = path.join(__dirname, '../middlewares');
const DOCS_DIR = path.join(__dirname, '../../docs/docs');
const MODULES_DIR = path.join(DOCS_DIR, 'modules');
const SWAGGER_FILE = path.join(__dirname, '../../docs/static/swagger.json');
const CACHE_FILE = path.join(__dirname, '.doc-cache.json');

// Configuration Ollama
const OLLAMA_URL = 'http://localhost:11434';
const OLLAMA_MODEL = 'llama3';

const HTTP_METHOD_INFO = {
  GET: { action: "r√©cup√®re", color: "#4caf50", icon: "üìñ" },
  POST: { action: "cr√©e", color: "#2196f3", icon: "‚ûï" },
  PUT: { action: "met √† jour", color: "#ff9800", icon: "‚úèÔ∏è" },
  PATCH: { action: "modifie", color: "#ff9800", icon: "üîß" },
  DELETE: { action: "supprime", color: "#f44336", icon: "üóëÔ∏è" }
};

// Cache pour √©viter la reg√©n√©ration inutile
function loadCache() {
  if (fs.existsSync(CACHE_FILE)) {
    return JSON.parse(fs.readFileSync(CACHE_FILE, 'utf8'));
  }
  return {};
}

function saveCache(cache) {
  fs.writeFileSync(CACHE_FILE, JSON.stringify(cache, null, 2));
}

function getFileHash(filePath) {
  if (!fs.existsSync(filePath)) return null;
  const content = fs.readFileSync(filePath, 'utf8');
  return crypto.createHash('md5').update(content).digest('hex');
}

// Appel √† Ollama pour g√©n√©rer des descriptions
async function generateWithOllama(prompt) {
  try {
    const response = await fetch(`${OLLAMA_URL}/api/generate`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        model: OLLAMA_MODEL,
        prompt,
        stream: false,
        options: {
          temperature: 0.3,
          top_p: 0.9
        }
      })
    });

    if (!response.ok) {
      throw new Error(`Ollama error: ${response.status}`);
    }

    const data = await response.json();
    return data.response.trim();
  } catch (error) {
    console.warn(`‚ö†Ô∏è Ollama indisponible (${error.message}), utilisation du fallback`);
    return null;
  }
}

// Analyse avanc√©e du code pour d√©tecter les services utilis√©s
function analyzeCodeFlow(routeFile, controllerFile, serviceFile) {
  const analysis = {
    hasAuth: false,
    hasValidation: false,
    hasDatabase: false,
    hasCaching: false,
    hasEmail: false,
    hasFileUpload: false,
    hasExternalAPI: false,
    middlewares: [],
    services: [],
    complexity: 'simple'
  };

  // Analyser le fichier de route
  if (fs.existsSync(routeFile)) {
    const routeContent = fs.readFileSync(routeFile, 'utf8');
    
    // D√©tection des middlewares
    const middlewareMatches = routeContent.match(/require\(['"]\.\.\/middlewares\/([^'"]+)['"]\)/g);
    if (middlewareMatches) {
      analysis.middlewares = middlewareMatches.map(m => 
        m.replace(/require\(['"]\.\.\/middlewares\/([^'"]+)['"].*/, '$1')
      );
    }
    
    // D√©tection d'authentification
    analysis.hasAuth = /auth|Auth|authenticate|jwt|token|middleware/i.test(routeContent);
    analysis.hasValidation = /valid|Valid|joi|yup|schema/i.test(routeContent);
  }

  // Analyser le fichier controller
  if (fs.existsSync(controllerFile)) {
    const controllerContent = fs.readFileSync(controllerFile, 'utf8');
    analysis.hasDatabase = /db|DB|query|model|repository|findAll|create|update|delete/i.test(controllerContent);
    analysis.hasEmail = /mail|email|sendgrid|nodemailer/i.test(controllerContent);
    analysis.hasFileUpload = /upload|multer|file/i.test(controllerContent);
  }

  // Analyser le fichier service
  if (fs.existsSync(serviceFile)) {
    const serviceContent = fs.readFileSync(serviceFile, 'utf8');
    analysis.hasCaching = /cache|Cache|redis/i.test(serviceContent);
    analysis.hasExternalAPI = /axios|fetch|http|api/i.test(serviceContent);
    
    // D√©tecter les services utilis√©s
    const serviceMatches = serviceContent.match(/require\(['"][^'"]*service[^'"]*['"]\)/g);
    if (serviceMatches) {
      analysis.services = serviceMatches.map(s => 
        s.replace(/.*\/([^\/'"]+)\.service.*/, '$1')
      );
    }
  }

  // D√©terminer la complexit√©
  const complexityScore = 
    (analysis.hasAuth ? 1 : 0) +
    (analysis.hasValidation ? 1 : 0) +
    (analysis.hasDatabase ? 1 : 0) +
    (analysis.hasCaching ? 1 : 0) +
    (analysis.hasEmail ? 1 : 0) +
    (analysis.hasExternalAPI ? 1 : 0) +
    analysis.middlewares.length +
    analysis.services.length;

  analysis.complexity = complexityScore <= 2 ? 'simple' : complexityScore <= 4 ? 'medium' : 'complex';

  return analysis;
}

// G√©n√©ration du diagramme Mermaid bas√© sur l'analyse du code
function generateSequenceDiagram(method, routePath, serviceName, analysis, swaggerOperation) {
  let diagram = `sequenceDiagram
    actor User as üë§ Utilisateur
    participant API as üåê API ${serviceName.toUpperCase()}`;
  
  // Ajouter les participants selon l'analyse r√©elle
  if (analysis.hasAuth) {
    diagram += `\n    participant Auth as üîê Service Auth`;
  }
  if (analysis.hasValidation) {
    diagram += `\n    participant Valid as ‚úÖ Validation`;
  }
  if (analysis.hasDatabase) {
    diagram += `\n    participant DB as üíæ Base de donn√©es`;
  }
  if (analysis.hasCaching) {
    diagram += `\n    participant Cache as ‚ö° Cache Redis`;
  }
  if (analysis.hasEmail) {
    diagram += `\n    participant Mail as üìß Service Email`;
  }
  if (analysis.hasExternalAPI) {
    diagram += `\n    participant ExtAPI as üåç API Externe`;
  }

  diagram += `\n\n    User ->> API: ${method} ${routePath}`;
  
  // Flux bas√© sur l'analyse r√©elle
  if (analysis.hasAuth) {
    diagram += `\n    API ->> Auth: V√©rification token JWT`;
    diagram += `\n    Auth -->> API: ‚úÖ Token valide`;
  }
  
  if (analysis.hasValidation) {
    diagram += `\n    API ->> Valid: Validation des donn√©es`;
    diagram += `\n    Valid -->> API: ‚úÖ Donn√©es valides`;
  }
  
  // Cache pour GET uniquement
  if (method === 'GET' && analysis.hasCaching) {
    diagram += `\n    API ->> Cache: Recherche en cache`;
    diagram += `\n    alt Donn√©es en cache`;
    diagram += `\n        Cache -->> API: üì¶ Donn√©es trouv√©es`;
    diagram += `\n        API -->> User: 200 OK + donn√©es`;
    diagram += `\n    else Cache manqu√©`;
  }
  
  // API externe si n√©cessaire
  if (analysis.hasExternalAPI) {
    diagram += `\n    API ->> ExtAPI: Appel API externe`;
    diagram += `\n    ExtAPI -->> API: üìä Donn√©es re√ßues`;
  }
  
  // Op√©ration base de donn√©es
  if (analysis.hasDatabase) {
    let dbAction = "SELECT";
    switch (method) {
      case 'POST': dbAction = "INSERT"; break;
      case 'PUT': case 'PATCH': dbAction = "UPDATE"; break;
      case 'DELETE': dbAction = "DELETE"; break;
    }
    diagram += `\n    API ->> DB: ${dbAction} ${serviceName}`;
    diagram += `\n    DB -->> API: üìã R√©sultat`;
    
    // Mise en cache apr√®s lecture DB
    if (method === 'GET' && analysis.hasCaching) {
      diagram += `\n    API ->> Cache: Mise en cache des r√©sultats`;
    }
  }
  
  // Email pour les cr√©ations/modifications
  if (analysis.hasEmail && ['POST', 'PUT'].includes(method)) {
    diagram += `\n    API ->> Mail: üìß Notification ${method === 'POST' ? 'cr√©ation' : 'modification'}`;
    diagram += `\n    Mail -->> API: ‚úÖ Email envoy√©`;
  }
  
  // Fermer le cache alt si ouvert
  if (method === 'GET' && analysis.hasCaching) {
    diagram += `\n    end`;
  }
  
  // R√©ponse finale
  const responseCode = method === 'POST' ? '201' : '200';
  const responseText = method === 'POST' ? 'Created' : 'OK';
  diagram += `\n    API -->> User: ${responseCode} ${responseText}`;
  
  return diagram;
}

// G√©n√©ration de la description avec Ollama
async function generateEndpointDescription(method, routePath, serviceName, analysis, swaggerOperation) {
  const contextPrompt = `
Tu es un expert en documentation API. G√©n√®re une description claire et concise pour cet endpoint:

M√©thode: ${method}
Route: ${routePath}
Service: ${serviceName}
Complexit√©: ${analysis.complexity}
Services d√©tect√©s: ${analysis.services.join(', ') || 'Aucun'}
Middlewares: ${analysis.middlewares.join(', ') || 'Aucun'}
Fonctionnalit√©s: ${[
  analysis.hasAuth ? 'Authentification' : '',
  analysis.hasValidation ? 'Validation' : '',
  analysis.hasDatabase ? 'Base de donn√©es' : '',
  analysis.hasCaching ? 'Cache' : '',
  analysis.hasEmail ? 'Email' : '',
  analysis.hasExternalAPI ? 'API externe' : ''
].filter(Boolean).join(', ')}

Swagger description: ${swaggerOperation?.summary || 'Non disponible'}

G√©n√®re une description en fran√ßais de maximum 100 caract√®res qui explique ce que fait cet endpoint de mani√®re claire et professionnelle.
R√©ponse attendue: Une seule phrase descriptive, sans emoji ni caract√®res sp√©ciaux.
`;

  const ollamaDescription = await generateWithOllama(contextPrompt);
  
  if (ollamaDescription) {
    return ollamaDescription;
  }
  
  // Fallback si Ollama n'est pas disponible
  const methodInfo = HTTP_METHOD_INFO[method];
  let fallback = `Endpoint qui ${methodInfo.action} `;
  
  if (routePath.includes(':id') || routePath.includes('{id}')) {
    fallback += `un(e) ${serviceName} sp√©cifique`;
  } else if (routePath === '/' || routePath === '') {
    fallback += method === 'GET' ? `la liste des ${serviceName}s` : `un(e) nouveau/elle ${serviceName}`;
  } else {
    fallback += `des donn√©es ${serviceName}`;
  }
  
  return fallback;
}

// G√©n√©ration des √©tapes d√©taill√©es avec Ollama
async function generateDetailedSteps(method, routePath, analysis, description) {
  const stepsPrompt = `
Bas√© sur cette analyse technique d'un endpoint ${method} ${routePath}:

Description: ${description}
Authentification: ${analysis.hasAuth ? 'Oui' : 'Non'}
Validation: ${analysis.hasValidation ? 'Oui' : 'Non'}
Base de donn√©es: ${analysis.hasDatabase ? 'Oui' : 'Non'}
Cache: ${analysis.hasCaching ? 'Oui' : 'Non'}
Email: ${analysis.hasEmail ? 'Oui' : 'Non'}
API externe: ${analysis.hasExternalAPI ? 'Oui' : 'Non'}
Middlewares: ${analysis.middlewares.join(', ') || 'Aucun'}

G√©n√®re une liste de 3-5 √©tapes techniques pr√©cises que suit cet endpoint, dans l'ordre chronologique.
Format: "√âtape X: Action pr√©cise"
Exemples: "√âtape 1: V√©rification du token JWT", "√âtape 2: Validation des donn√©es d'entr√©e"

R√©ponse en fran√ßais, une √©tape par ligne, num√©rot√©es de 1 √† N.
`;

  const ollamaSteps = await generateWithOllama(stepsPrompt);
  
  if (ollamaSteps) {
    return ollamaSteps.split('\n').filter(line => line.trim().startsWith('√âtape'));
  }
  
  // Fallback bas√© sur l'analyse
  const steps = [];
  let stepNum = 1;
  
  if (analysis.hasAuth) steps.push(`√âtape ${stepNum++}: V√©rification de l'authentification`);
  if (analysis.hasValidation) steps.push(`√âtape ${stepNum++}: Validation des donn√©es d'entr√©e`);
  if (method === 'GET' && analysis.hasCaching) steps.push(`√âtape ${stepNum++}: V√©rification du cache`);
  if (analysis.hasExternalAPI) steps.push(`√âtape ${stepNum++}: Appel vers l'API externe`);
  if (analysis.hasDatabase) {
    const action = method === 'GET' ? 'Lecture' : method === 'POST' ? 'Insertion' : 'Modification';
    steps.push(`√âtape ${stepNum++}: ${action} en base de donn√©es`);
  }
  if (analysis.hasEmail && ['POST', 'PUT'].includes(method)) steps.push(`√âtape ${stepNum++}: Envoi de notification email`);
  steps.push(`√âtape ${stepNum++}: Retour de la r√©ponse HTTP`);
  
  return steps;
}

async function generateDocumentationForEndpoint(method, routePath, serviceName, swaggerOperation, analysis) {
  const methodInfo = HTTP_METHOD_INFO[method];
  
  // Description g√©n√©r√©e par Ollama
  const description = await generateEndpointDescription(method, routePath, serviceName, analysis, swaggerOperation);
  
  // Param√®tres depuis Swagger
  const parametres = [];
  if (swaggerOperation?.parameters) {
    swaggerOperation.parameters.forEach(param => {
      parametres.push({
        nom: param.name,
        type: param.schema?.type || param.type || 'string',
        description: param.description || `Param√®tre ${param.in}`,
        obligatoire: param.required || false,
        localisation: param.in
      });
    });
  }
  
  if (swaggerOperation?.requestBody) {
    parametres.push({
      nom: 'body',
      type: 'object',
      description: swaggerOperation.requestBody.description || 'Corps de requ√™te JSON',
      obligatoire: swaggerOperation.requestBody.required || false,
      localisation: 'body'
    });
  }
  
  // √âtapes d√©taill√©es g√©n√©r√©es par Ollama
  const flux = await generateDetailedSteps(method, routePath, analysis, description);
  
  return { description: `${methodInfo.icon} ${description}`, parametres, flux };
}

function generateModulePage(moduleName, endpoints) {
  const moduleTitle = moduleName.charAt(0).toUpperCase() + moduleName.slice(1);
  
  let content = `---
id: ${moduleName}
title: üì¶ Module ${moduleTitle}
sidebar_label: ${moduleTitle}
---

# Module ${moduleTitle}

Ce module g√®re les op√©rations li√©es aux **${moduleName}s**. Il contient ${endpoints.length} endpoint(s).

## Vue d'ensemble

`;

  // Table des endpoints
  content += `| M√©thode | Route | Description |\n`;
  content += `|---------|-------|-------------|\n`;
  
  endpoints.forEach(endpoint => {
    const icon = HTTP_METHOD_INFO[endpoint.method]?.icon || 'üìå';
    const desc = endpoint.documentation.description.length > 80 
      ? endpoint.documentation.description.substring(0, 77) + '...'
      : endpoint.documentation.description;
    content += `| ${icon} **${endpoint.method}** | \`${endpoint.route}\` | ${desc} |\n`;
  });

  content += `\n---\n\n`;

  // D√©tail de chaque endpoint
  endpoints.forEach((endpoint, index) => {
    const methodInfo = HTTP_METHOD_INFO[endpoint.method];
    
    content += `## ${methodInfo.icon} ${endpoint.method} ${endpoint.route}\n\n`;
    
    // Description
    content += `### üìã Description\n\n${endpoint.documentation.description}\n\n`;
    
    // Badge de complexit√©
    const complexityBadge = endpoint.analysis.complexity === 'complex' ? 'üî¥ Complexe' : 
                           endpoint.analysis.complexity === 'medium' ? 'üü° Moyen' : 'üü¢ Simple';
    content += `**Complexit√©:** ${complexityBadge}\n\n`;
    
    // Services utilis√©s
    if (endpoint.analysis.services.length > 0 || endpoint.analysis.middlewares.length > 0) {
      content += `**Services utilis√©s:** ${[...endpoint.analysis.services, ...endpoint.analysis.middlewares].join(', ')}\n\n`;
    }
    
    // Diagramme de s√©quence
    content += `### üîÑ Flux d'ex√©cution\n\n`;
    content += `\`\`\`mermaid\n${endpoint.sequenceDiagram}\n\`\`\`\n\n`;
    
    // Param√®tres si pr√©sents
    if (endpoint.documentation.parametres.length > 0) {
      content += `### üìù Param√®tres\n\n`;
      content += `| Nom | Type | Obligatoire | Localisation | Description |\n`;
      content += `|-----|------|-------------|--------------|-------------|\n`;
      
      endpoint.documentation.parametres.forEach(param => {
        const required = param.obligatoire ? '‚úÖ' : '‚ùå';
        const location = param.localisation === 'path' ? 'üõ§Ô∏è Path' : 
                        param.localisation === 'query' ? '‚ùì Query' :
                        param.localisation === 'body' ? 'üì¶ Body' : 'üìã ' + param.localisation;
        content += `| **${param.nom}** | \`${param.type}\` | ${required} | ${location} | ${param.description} |\n`;
      });
      content += `\n`;
    }
    
    // √âtapes d√©taill√©es
    content += `### üìã √âtapes d√©taill√©es\n\n`;
    endpoint.documentation.flux.forEach(step => {
      content += `- ${step}\n`;
    });
    content += `\n`;
    
    if (index < endpoints.length - 1) {
      content += `---\n\n`;
    }
  });
  
  return content;
}

async function generateDocusaurusPages() {
  console.log('üìö G√©n√©ration des pages Docusaurus avec Ollama...');

  // Test de connexion Ollama
  try {
    const testResponse = await fetch(`${OLLAMA_URL}/api/tags`);
    if (testResponse.ok) {
      console.log('‚úÖ Ollama connect√©');
    }
  } catch (error) {
    console.log('‚ö†Ô∏è Ollama non disponible, utilisation du mode fallback');
  }

  if (!fs.existsSync(SWAGGER_FILE)) {
    console.error(`‚ùå Fichier Swagger manquant: ${SWAGGER_FILE}`);
    return;
  }

  // Cr√©er les r√©pertoires
  if (!fs.existsSync(MODULES_DIR)) {
    fs.mkdirSync(MODULES_DIR, { recursive: true });
  }

  const cache = loadCache();
  const files = glob.sync(`${ROUTES_DIR}/*.route.js`);
  const loadedSwaggerSpec = JSON.parse(fs.readFileSync(SWAGGER_FILE, 'utf8'));
  
  // Grouper par module
  const moduleData = {};
  let hasChanges = false;
  
  for (const file of files) {
    const serviceName = path.basename(file, '.route.js');
    const fileHash = getFileHash(file);
    
    // V√©rifier si le fichier a chang√©
    const cacheKey = `${serviceName}_${fileHash}`;
    if (cache[cacheKey] && !process.argv.includes('--force')) {
      console.log(`‚è≠Ô∏è ${serviceName} inchang√©, skip...`);
      continue;
    }
    
    hasChanges = true;
    const controllerFile = path.join(CONTROLLERS_DIR, `${serviceName}.controller.js`);
    const serviceFile = path.join(SERVICES_DIR, `${serviceName}.service.js`);
    
    // Analyse du code
    const analysis = analyzeCodeFlow(file, controllerFile, serviceFile);
    
    if (!moduleData[serviceName]) {
      moduleData[serviceName] = [];
    }
    
    const fileContent = fs.readFileSync(file, 'utf8');
    const ROUTE_REGEX = /\.(get|post|put|delete)\(['"]([^'"]+)['"]\s*,\s*([^)]+)\)/g;
    
    let match;
    while ((match = ROUTE_REGEX.exec(fileContent)) !== null) {
      const method = match[1].toUpperCase();
      const routePath = match[2];
      
      // Correspondance Swagger
      const swaggerPath = routePath.replace(/:([^/]+)/g, '{$1}');
      const swaggerOperation = loadedSwaggerSpec.paths?.[swaggerPath]?.[method.toLowerCase()];
      
      // G√©n√©rer la documentation avec Ollama
      const documentation = await generateDocumentationForEndpoint(
        method, routePath, serviceName, swaggerOperation, analysis
      );
      
      // G√©n√©rer le diagramme de s√©quence
      const sequenceDiagram = generateSequenceDiagram(
        method, routePath, serviceName, analysis, swaggerOperation
      );
      
      moduleData[serviceName].push({
        method,
        route: routePath,
        documentation,
        sequenceDiagram,
        analysis
      });
    }
    
    // Mettre √† jour le cache
    cache[cacheKey] = Date.now();
  }
  
  if (!hasChanges) {
    console.log('‚úÖ Aucun changement d√©tect√©, documentation √† jour');
    return;
  }
  
  // G√©n√©rer les pages
  const moduleNames = [];
  for (const [moduleName, endpoints] of Object.entries(moduleData)) {
    if (endpoints.length === 0) continue;
    
    const pageContent = generateModulePage(moduleName, endpoints);
    const filePath = path.join(MODULES_DIR, `${moduleName}.md`);
    
    fs.writeFileSync(filePath, pageContent);
    moduleNames.push(moduleName);
    
    console.log(`‚úÖ Page g√©n√©r√©e: ${moduleName} (${endpoints.length} endpoints)`);
  }
  
  // Sauvegarder le cache
  saveCache(cache);
  
  console.log(`\nüéâ ${moduleNames.length} pages g√©n√©r√©es dans ${MODULES_DIR}`);
  console.log('üìÅ Structure cr√©√©e:');
  moduleNames.forEach(name => console.log(`   üìÑ ${name}.md`));
}

function updateSidebar(modules) {
  const sidebarPath = path.join(DOCS_DIR, '../sidebars.js');
  
  if (!fs.existsSync(sidebarPath)) {
    console.warn('‚ö†Ô∏è sidebars.js non trouv√©');
    return;
  }
  
  let sidebarContent = fs.readFileSync(sidebarPath, 'utf8');
  console.log('üìã Mise √† jour du tutorialSidebar...');
  
  if (modules.length > 0) {
    const moduleItems = modules.map(m => `'modules/${m}'`).join(',\n        ');
    const moduleSection = `    {
      type: 'category',
      label: 'üìö API Modules',
      items: [
        ${moduleItems}
      ],
    }`;
    
    // V√©rifier si la section modules existe d√©j√†
    const hasModulesSection = sidebarContent.includes('üìö API Modules');
    
    if (hasModulesSection) {
      // Remplacer la section existante
      sidebarContent = sidebarContent.replace(
        /\s*{\s*type:\s*['"]category['"],\s*label:\s*['"]üìö API Modules['"][^}]*items:\s*\[[^\]]*\][^}]*},?/gs,
        '\n' + moduleSection + ','
      );
      console.log('üîÑ Section modules mise √† jour');
    } else {
      // Ajouter la nouvelle section √† la fin du tutorialSidebar
      const tutorialSidebarRegex = /(tutorialSidebar:\s*\[[\s\S]*?)(\s*\],?\s*})/;
      const match = sidebarContent.match(tutorialSidebarRegex);
      
      if (match) {
        const beforeClosing = match[1];
        const closing = match[2];
        
        // Ajouter une virgule si n√©cessaire avant la nouvelle section
        const needsComma = beforeClosing.trim().endsWith('},') || beforeClosing.trim().endsWith('}');
        const comma = needsComma ? '' : ',';
        
        sidebarContent = sidebarContent.replace(
          tutorialSidebarRegex,
          beforeClosing + comma + '\n' + moduleSection + ',' + closing
        );
        console.log('‚ûï Section modules ajout√©e au tutorialSidebar');
      }
    }
  }
  
  fs.writeFileSync(sidebarPath, sidebarContent);
}